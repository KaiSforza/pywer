#!/usr/bin/env python3
__doc__ = '''
pywer AUR downloader

MIT/X Consortium License

Â© 2013-13 William Giokas <1007380@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
'''

import libaur.printer
import libaur.errors as error
import libaur
import configparser
import xdg.BaseDirectory
import argparse
import re
from os import path
from sys import exit

pywer_config_ver = 3

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
            usage='%(prog)s [options] operation [target [target...]]',
            description='A simple AUR helper in python.',
            epilog='See the config file in $PREFIX/share/doc/pywer. \
                   Copy it to {} and edit it for use, or use `--config`.\
                   You may need to update the config file when updating\
                   pywer.'\
                   .format(xdg.BaseDirectory.xdg_config_home),
                   )
    # Operations
    # TODO: Find some way to only allow a single operation
    parser.add_argument('targ',
                        help='target to perform \'operation\' on',
                        nargs='*', default=None, metavar='target')
    operations = parser.add_argument_group('Operations')
    operations.add_argument('-s', '--search',
                        help='Search for this package',
                        action='count', default=0)
    operations.add_argument('-i', '--info',
                        help='Get info for this package',
                        action='count', default=0)
    operations.add_argument('-m', '--msearch',
                        help='Search for this maintainers packages',
                        action='count', default=0)
    operations.add_argument('-u', '--update',
                        help='Print package updates for the system',
                        action='count', default=0)
    operations.add_argument('-d', '--download',
                        help='Download the package',
                        action='count', default=0)

    # Options
    options = parser.add_argument_group('Options')
    options.add_argument('-q', '--quiet',
                        help='Be quieter',
                        action='count', default=0)
    options.add_argument('-v', '--verbose',
                        help='Be verbose',
                        action='count', default=0)
    options.add_argument('-f', '--force',
                        help='overwrite existing files while downloading',
                        action='store_true')
    options.add_argument('--config',
                        help='Specify an alternate config',
                        metavar='file')
    options.add_argument('-V', '--version',
                        help='Print version',
                        action='version', version='%(prog)s {}'.format(libaur.__version__))
    options.add_argument('-o', '--ignore-ood',
                        help='Ignore out of date packages',
                        action='store_true')
    options.add_argument('--no-ignore-ood',
                        help='Do not ignore out of date packages',
                        action='store_true')
    options.add_argument('-c', '--color',
                        help='Use color. One of \'always\', \'auto\' or \'never\'',
                        metavar='when')
    options.add_argument('--ignorerepo',
                        help='Specify comma separated list of repos to ignore',
                        metavar='repo', nargs='+')
    options.add_argument('-t', '--target',
                        help='Specify an alternate download location',
                        metavar='dir')
    options.add_argument('--baseurl',
                        help='Set a custom baseurl to an AUR',
                        metavar='url')
    options.add_argument('--dbpath',
                        help='Set a custom dbpath (for -u)',
                        metavar='path')
    args = parser.parse_args()

    config = configparser.ConfigParser()
    if args.config:
        use_config = args.config
    else:
        use_config = xdg.BaseDirectory.xdg_config_home + '/pywer/pywer.ini'
    config.read(use_config)

    if pywer_config_ver != config.getint('PYWER', 'CONFIGVER'):
        raise error.ConfigWrongVersion('''Your pywer config is for an older
        version of pywer. Please see the file in $PREFIX/share/doc/pywer.''')


    if not path.exists(use_config):
        message = 'pywer requires a config file at {}. See `pywer -h`.'\
                .format(use_config)
        raise error.ConfigMissing(message)

    SHOW_OOD=True
    if args.ignore_ood or config['Repos']['IgnoreOOD'] == 'yes':
        SHOW_OOD=False
    if args.no_ignore_ood:
        SHOW_OOD=True

    if args.color == 'always':
        USE_COLOR = 2
    elif args.color == 'auto':
        USE_COLOR = 1
    elif args.color == 'never':
        USE_COLOR = 0
    elif config['Printing']['Color'] == 'always':
        USE_COLOR = 2
    elif config['Printing']['Color'] == 'auto':
        USE_COLOR = 1
    else:
        USE_COLOR = 0

    VERBOSE = args.verbose - args.quiet

    if args.dbpath:
        ROOT=args.dbpath
    else:
        ROOT=config['pacman']['Root']


    if sum([args.search, args.msearch, args.info, args.download,
            args.update]) != 1:
        if not args.info == 2:
            raise error.ArgError('Invalid operation')


    FORCE=False
    if args.force:
        FORCE=True

    if args.baseurl:
        _baseurl = args.baseurl
    else:
        _baseurl = config['AUR']['BaseUrl']

    if args.search and args.targ:
        libaur.printer.pretty_print_search(args.targ, baseurl=_baseurl,
                ood=SHOW_OOD, be_verbose=VERBOSE, color=USE_COLOR)
    elif args.msearch and args.targ:
        libaur.printer.pretty_print_search(args.targ, stype='msearch',
                baseurl=_baseurl, ood=SHOW_OOD, be_verbose=VERBOSE,
                color=USE_COLOR)
    elif args.info and args.targ:
        if args.info > 1:
            libaur.printer.pretty_print_simple_info(args.targ, baseurl=_baseurl,
                    ood=SHOW_OOD, color=USE_COLOR, more_info=True, root=ROOT)
        else:
            libaur.printer.pretty_print_simple_info(args.targ, baseurl=_baseurl,
                    ood=SHOW_OOD, color=USE_COLOR, root=ROOT)
    elif args.download and args.targ:
        if args.target:
            dl_path = path.expanduser(args.target)
        else:
            dl_path = path.expanduser(config['Filesystem']['DownloadPath'])
        dl_path = path.expandvars(dl_path)
        libaur.printer.download_pkgs(args.targ, dl_path, dl_verbose=VERBOSE,
                baseurl=_baseurl, dl_force=FORCE, ood=SHOW_OOD, color=USE_COLOR)
    if args.update:
        if args.ignorerepo:
            repo_ignore = args.ignorerepo
        else:
            repo_ignore = re.split(',', config['Repos']['IgnoreRepo'])

        if not args.targ:
            libaur.printer.pretty_print_updpkgs(other_repos=repo_ignore,
                    baseurl=_baseurl, be_verbose=VERBOSE, root=ROOT,
                    color=USE_COLOR)
        else:
            libaur.printer.pretty_print_updpkgs(other_repos=repo_ignore,
                    baseurl=_baseurl, pkgs=args.targ, be_verbose=VERBOSE,
                    root=ROOT, color=USE_COLOR)
    else:
        print('Invalid poeration specified. (Use -h for help)')
        exit(1)
